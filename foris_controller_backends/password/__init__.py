#
# foris-controller
# Copyright (C) 2019 CZ.NIC, z.s.p.o. (http://www.nic.cz/)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
#

import logging
import pbkdf2
import pathlib

from foris_controller_backends.cmdline import BaseCmdLine, BackendCommandFailed
from foris_controller_backends.uci import (
    UciBackend, get_option_named, UciException, UciRecordNotFound
)
from foris_controller_backends.files import BaseMatch


logger = logging.getLogger(__name__)


FILTER_PASSWORDS_FILES_MATCH = "/usr/share/common_passwords/*"


def pawned_password(password):
    for path in BaseMatch.list_files([FILTER_PASSWORDS_FILES_MATCH]):
        file_name = pathlib.Path(path).name
        list_name = file_name[:-len("_passwords")] if file_name.endswith("_passwords") \
            else file_name
        with open(path, "rb") as f:
            line = f.readline()
            while line:
                # remove newline
                line = line[:-1] if line[-1] == b"\n" else line
                if not line:
                    continue
                try:
                    stored_pass, count_str = line.rsplit(b"\t", 1)
                    if stored_pass == password:
                        return list_name, int(count_str)
                except ValueError:
                    pass

                line = f.readline()
    return None


class ForisPasswordUci(object):
    def set_password(self, password):
        pawned = pawned_password(password)
        if pawned:
            list_name, count = pawned
            return {"result": False, "list": list_name, "count": count}

        # use 48bit pseudo-random salt internally generated by pbkdf2
        new_password_hash = pbkdf2.crypt(password, iterations=1000)
        with UciBackend() as backend:
            backend.add_section("foris", "config", "auth")
            backend.set_option("foris", "auth", "password", new_password_hash)

        # update wizard passed in foris web (best effort)
        try:
            from foris_controller_backends.web import WebUciCommands
            WebUciCommands.update_passed("password")
        except UciException:
            pass

        return {"result": True}

    def check_password(self, password):
        with UciBackend() as backend:
            foris_data = backend.read("foris")

        # This could raise UciRecordNotFound which should be caught elsewhere
        password_hash = get_option_named(foris_data, "foris", "auth", "password")

        return password_hash == pbkdf2.crypt(password, salt=password_hash)

    @staticmethod
    def is_password_set(foris_data):
        try:
            get_option_named(foris_data, "foris", "auth", "password")
            return True
        except (UciRecordNotFound, UciException):
            return False


class SystemPasswordCmd(BaseCmdLine):

    def set_password(self, password):
        pawned = pawned_password(password)
        if pawned:
            list_name, count = pawned
            return {"result": False, "list": list_name, "count": count}
        busybox_passwd = "/bin/passwd"
        logger.debug("Setting system password.")
        passwords = password + b"\n" + password + b"\n"
        retval, _, _ = self._run_command(busybox_passwd, input_data=passwords)
        if retval != 0:
            logger.error("Failed to set system password.")
            raise BackendCommandFailed(retval, [busybox_passwd])

        return {"result": True}
